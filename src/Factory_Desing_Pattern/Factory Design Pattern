Simple Factory:-
First we have to get the instance of the database, How ?
    sendEmail (Config db_type) {
        if(db_type.db == "mysql"){
            Database db = new Mysql();
        }else if(db_type.db == "mongo"){
            Database db = new Mongo();
        }
        else if(db_type.db == "postgres"){
            Database db = new postgres();
        }
Now we have to send the email, so we get the User from db and send the email
        db.getUsers().sendEmail();

Database Factory:-
        1.  create method called createDbForType().
        2.  what is the parameter for this method   ==>     db_type
        3.  what is the return type of this method.
                    Can we return multiple types of objects from this method      ==>     No.
                        means we had a common interface called Database. so we will return the Database object (parent type).   not the child class obj, becoz child class can be change in future. (Dependency Inversion Principle)
       this sol is know as Simple Factory.

       Code:-
                createDbForType (type db_type) {
                    Database db;
                    switch(db_type){
                        case "mysql":
                            db = new Mysql();
                            break;
                        case "mongo":
                            db = new Mongo();
                            break;
                        case "postgres":
                            db = new Postgres();
                            break;
                    }
                    return db;          //returning the parent type object.
                }
       Even though it has multiple if else, but it is still not violating the SRP, becoz it is only responsible for creating the object.
       it is maintainable. if we have to add new db, we just have to add new case in switch statement.
       it is reusable. we can use this method to create any type of db object.
       DatabaseFactory is still violating the OCP but EmailService is not violating the OCP.
EmailService:-
         sendEmail (Config db_type) {
            DatabaseFactory dbFactory = new DatabaseFactory();
            Database db = dbFactory.createDbForType(db_type.db);
            db.getUsers().sendEmail();
                }
*********************************************************************************************************************************************************************

Factory Method:-
        Now we are converting our Database interface to abstract class.
        common class:-
                                        Class abstract Database {                                                                                                                                                          |                                interface  Query {
                                            String host;                                                                                                                                                                               |
                                            String port;                                                                                                                                                                                |                               }
                                            Type type;                                                                                                                                                                                  |
                                            connect();                                                                                                                                                                                  |
                                            terminate();                                                                                                                                                                                |
                                            createQuery();      -->     Query Object.                                                                                                                                  |
                                        }                                                                                                                                                                                                       |
                                                                                                                                                                                                                                                 |
        implementation class:-                                                                                                                                                                                                 |
                                       class Mysql                                               class MongoDb                                        class Postgres                                         |                       class MysqlQuery                        class MongoDbQuery                            classPostgresQuery
                                        {                                                                   {                                                                   {                                                               |                       {                                                       {                                                                   {
                                              return MysqlQuery object                      return MongoDbQuery object              return PostgresQuery object          |
                                        }                                                                    }                                                                   }                                                              |                       }                                                        }                                                                   }

        example class:-
                    class Mysql extends Database {
                        Query createQuery() {
                            return new MysqlQuery();
                        }  }

        Main class:-
                    class Main{
                        psvm {
                                Database db = new Mysql();                // instance of actual database.
                                Query query = db.createQuery();             // create an query.
                                     // assume instead of Mysql we want to use Postgres then what do we have to change.        ==>            we just have to replace this 'new Mysql()'    with    this 'new Postgres()' only.         we don't have to change in db.createQuery();
                        }  }
        REQUIREMENT:-    add new Database.      1.    we create a Casandra class as well CasandraQuery class.     2.  In Main class we just have to create Casandra class obj & call createQuery().
        *************** createQuery() is an Factory Method *********************


In simple factory, we are doing:-
        we creating Database Factory    {
                createQuery(it takes 'type' as a parameter){
                    ....
                }
        }

now In factory method, we are doing:-
        now we have actual database class{
            this createQuery() will create diff types of Query Object based on the database.
        }
*****************************************************************************************************************************************************************************************
Abstract Factory:-
class Theme{
    Color primary_color;    // ENUM
    Font font;
    changeColor();      // attribute modification methods.
    createButton();     // factory method:- means we want to create a button for the particular theme.  so we use factory method here.
    createMenu();      // factory method
}
    Ques:- Does this above class violate SRP ?
    Ans :-  Yes, becoz we have multiple factory methods, attribute modification methods etc.  so we are using Abstract Factory.

Ques:-  How can we improve that so that it can't violate SRP ?
Ans :-   "We can break this Theme class into multiple classes". like
                -   We create Theme class which has attributes only & we have removed the factory method from it.
                -   We create new ThemeComponentFactory interface (it is responsible to create Component).
                                                    Before                                                                                                                                             After
                    Class Theme {                       interface     1.  we created Theme package & it has Theme class with base implementation.  {                                   ==>                         Class Theme {
                            name;                                   createButton();                                                                                                         name;   color;
                            color;      }                             createMenu();     }                                                                                                    createComponentFactory();  }

             Ques:-  In Main class, we should use Theme class (parent) or we should use its child class (Dark theme, light theme) ?
             Ans :-   we should use child class, so we will create DarkTheme, PrimaryTheme etc.

             Ques:-  We want to create a Button, what will I do ?
             Ans :-
                            first we have to create the Theme, so we do Theme dark = new DarkTheme();
                            second we want to create the button so we have to access ThemeComponentFactory class which has factory method called createButton()     OR
                            What can we do In my Theme class to have access ThemeComponentFactory class.                {Note:- we can't implements the ThemeComponentFactory class into the Theme class}
                                we cn do is:-    1.   In Theme class we can add a attribute of something called ThemeComponentFactory themeFactory;    (it is an attribute of type ThemeComponentFactory interface).
                                                           2.   In Theme class we can add a factory method called createComponentFactory()   {this method will return the object of that class which has already lots of factory methods are present} so we can called it as factory of factory
Implementation:-        Class DarkTheme extends Theme {         // we are using After Theme class.
                                                createComponentFactory{
                                                    return new DarkComponent();
                                                }  }

